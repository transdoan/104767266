We decided to use Finance as the basis of our project because of its features like “Register”, “Login”, “Log Out” and Flask configurations. However, we decided to add extra tabs by inserting redirects into layout.html.

Create: Create is a tab that allows users to create an entry. In the template, create.html, we used an HTML form to gather the input for the entry. The form is then submitted using the POST method to the function create, which will insert the song name to the Songs table, artist name to the Artists table, and everything into the Entries table where it’ll be assigned its own entry id. Entries need to be private or public, which we set to be 1 and 0 in the entries table as the privacy column. If an entry is missing something, the user will receive an error message. After you create, in the discover tab, all of the entries will only be previews. You can view the full entry by simply clicking on the entry. By clicking on the entry, the user will be redirected to entryfull.html, which is a page that displays the full entry utilizing a similar template as create.html.

Discover: Discover is a tab that allows users to see all entries (only public entries, i.e. entries with privacy = 0) submitted except theirs. We decided to implement a filter by genre feature, since it’s important for users to be able to discover new music similar to their tastes. To accomplish this, we added a new filter.html that has the same template as Discover, but this time, it has a different jinja loop that only displays the entries that match the genre chosen. From these results, both the entries and usernames are clickable, to allow for more interactiveness. In order to do this, we added an <a> tag to the jinja table, making the row specific clickable. The <a> tag defines a hyperlink. So, by adding this tag to the row that prints the username, we are able to link this to a method in app.py. So, when the username is clicked, the function is called; the function will display that user’s profile. Once the user has clicked on an account’s profile, they can choose to follow/unfollow.

Follow/unfollow: Follow and unfollow are features that we implemented using multiple python functions. The template that calls on Follow() is index.html, which displays the profile of any user that is not the current user or a user that’s already followed by the current user because it has the button “follow”. Follow() runs when the user submits a POST request to the function, letting it access the user_id of the user who the current user wants to follow. It then checks if the user already followed that person, if yes, then returns apology4.html. If not, then it will insert the current user’s id and the user id of the person the current user wants to follow (following_id) to the Follows table. Unfollow() does the same thing but it just deletes the row where user_id = current user’s id and following_id = the user id of the followed user. Both Follow() and Unfollow() then directs the user to /feed, which renders the following feed, displaying all the entries of those the current user followed. Followed users will have their profiles rendered using the template, profilefollowed.html, so that the “follow” button becomes “unfollow” and so that the current user can unfollow them.

Favorited/Unfavorited/Favorites: Favorited() and Unfavorited() are functions that pretty much work like follow and unfollow. Favorited() gets the user_id and the entry_id of the post they want to favorite and add it to the Favorites table. It then redirects the user to Favorites(), which renders a table showing all the favorited entries using the favorites.html template. Since entries in this table have been favorited, we made the function Entryfullfavorited() to render an expanded entry that displays the “Unfavorite” button instead of “Favorite”. If a user clicks on the “unfavorite” button, it requests a GET method to Unfavorited(), which will then delete the row with the user_id and that entry_id.

Search: Additionally, there is a search tab that allows a user to search for accounts and be able to follow them. This is an important feature to include as we want users to be able to search and follow their own friends. In order to do this, a search.html was made that served as the template for the search tab. The search.html passes on the input variable to the function in app.py. From this function, we ran a SQL query in order to select only the usernames from the users table that match the search-input using “LIKE.” These results are displayed in the results.html, which also has the usernames as a clickable link to the account’s profile.

My radio: My radio tab is a very personal tab, documenting all of the user’s entries - public AND private. From this tab, the user can see all of their entries along with the connected information (song, artist, and time). These entries are ordered by most recent at the top. In the same way as discover, my radio only has a preview of the entries. Once the entry is clicked, the link from the html table leads us to the entryfull.html, which actually displays the full entry.

Edit profile: For the edit profile tab, we wanted to ensure that a user’s profile was more lively and included a profile picture. We decided to add preset icons that the user can choose from and change. In order to do this, we uploaded 6 icons (image source: Canva) into the static folder to allow the images to be accessible. In the editprofile.html there is a form that allows the user to select a specific profile picture (whose value is /static/X.png). Once the selection is submitted, this selection is passed onto the app.py function, index(). From this function, the mainprofile.html is rendered; this html displays the user’s updated profile with their updated profile picture.
